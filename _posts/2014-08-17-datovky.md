---
layout: post
title: Datové struktury
---

binární stromy
---
- máme lineárně uspořádané univerzum U, v něm podmnožinu S
- podmnožinu S chceme reprezentovat
- BVS je úplný binární strom (tj. každý vrchol je buď list nebo má 2 syny) , kde existuje bijekce mezi nody a věcmi z S, vlevo menší vpravo větší
- vnitřní nody reprezentují věci, listy reprezentují intervaly
    - podle Koubka to "vyhlíží logičtěji" s nima
    - supr
    - normálně se ty listy můžou vynechávat
- vyhledávání trvá podle hloubky - musíme vyvažovat

- jednoduchá rotace: 
    - přehodíme dva vnitřní nody a převěsíme syny
- dvojitá rotace:
    - popřevěšujeme tři nody
    - v w u , v je syn w, u je syn v na "druhou stranu"
        - pověsíme nahoru u, jako jeho syny v a w, převěsíme
- AVL stromy
    - pro každý nod se hloubka L a P podstromu liší max o 1
        - v každém nodu si pamatuujeme "vyváženost", tj. který podstrom je jak velký
        - nemusíme si pak pamatovat samotné hloubky
    - hloubka kořene je Phi(log n), tj. shora i sdola omezený
    - po vložení musíme dělat kontrolu
        - jedeme od vloženého směrem nahoru
        - u prvního nevyrovnaného uděláme rotaci
        - pokud je to left-left, uděláme jednoduchou rotaci
        - pokud je to left-right, uděláme dvojitou
        - u první kontroly končíme (!!!)
    - mažeme tak, že nahradíme nod nejpravějším levého substromu a jeho subtree pak hodíme místo něho
        - kontrola musí jet až nahoru, protože u rotace jsme snížili, takže musíme jet až nahoru
- červenočerné stromy
    - listy jsou černé
    - když je červený, je buď kořen, nebo je jeho otec černý 
    - stejný počet černých od kořene ke všem listům
        - takže hloubka je O(log n)

    - vyvažování:
        - právě vložený je vždycky červený
        - po vložení řešíme:
            - když je otec černý nebo otec kořen, trivia
            - když je otec červený a strýc červený, přebarvíme otcovskou generaci, ale kvůli počtům musíme zčervenit děda a jet výš
            - pokud tohle udělat nemůžeme, rotujeme
        - při mazání:
            - zase je to komplikovanější než insert, kdo by to čekal
            - kašlu na to
    - liší se to od AVL proto, že i u delete musíme provést jenom max. dvě rotace

haldy
---
- halda nepotřebuje efektivní operaci member
- chceme ale efektivní MIN, a delete/deletemin
    - chceme taky DELETE / INC / DEC, ale dostaneme k tomu umístění prvku, takže nemusíme hledat
    - hledat musíme umět minimum

- halda je na to

- halda je libovolný (i nebin) strom, kde otec je menší než synové

- reg halda
    - halda, kde každý vrchol má max. N synů (u binhaldy 2); 
    - nody jsou očíslované, že
        - když vrchol není list, každý menší má právě N synů, každý větší je list
        - tj. plní jakoby pole zleva
    - výška je log_N n
    - bublání a tak

    - makeheap: vytvoříme haldu, naplníme, u každého bubláme dolu
        - je to nějaký jednodušší nebo co
    - heapsort: opakovaně mažeme min z haldy

- leftist halda
    - nalevo nakloněná halda
    - je to halda
    - npl(x) - null path length - je největší perfektní bintree co je v podstromu pod x (a je rooted v x)
        - npl(levo) >= npl(pravo), tj vlevo vždycky "těžší"
    - The right path (path from root to rightmost leaf) is as short as any in the tree.
        - jo to platí
    - výhoda: pravé podstromy jsou velmi krátké
    - slučujeme:
        - rekurzivně
        - vezmeme tu s menším kořenem, její levý podstrom dáme doleva, jako pravý podstrom sloučení pravého podstromu a té druhé haldy
        - počet rekurzivních volání je součet pravých cest, proto se nám hodí krátké pravé cesty
        - i tak je nejhorší složitost merge O(log)

- fibonacciho halda
    - fibonacciho halda je taková divná věc, co ani neni strom (!!)
    - je to víc stromů, kde si navíc držíme ukazatel na nejmenší
    - každý z těch stromů je klasická halda, tj otec menší synů
    - nerozpadlá vypadá tak, že každá z nich má izomorfnost s binomiálním stromem a nejsou dvě stejně
        - ale my jí povolíme se "dočasně" rozpadnout, že to pak později konzolidujeme
    - některé uzly jsou označeny
    - insert jenom vloží nový strom kde je jenom ten jeden uzel
    - delete min nechá rozpadnout min a pak spojuje
    - amortizovaná složitost (??) tohohle delmin je O(rank(H)) kde rank je počet stromů, a to je <= log (n)
    - při decrease, co by rušila haldovitost - syna prostě odebereme a hodíme jako další strom
        - otcové, co jsme jim usekli jednoho syna, obarvíme
        - pokud jim chceme sekat i druhého syna, tak je radši taky usekneme a hodíme jako další strom
        - a rekurzivně nahoru
    - z nějakého důvodu to funguje
        - ale to rank <= log(n) funguje jenom kvůli tomu rozpadávání
    - Proto se hodně používají v grafových algoritmech, 
kde umožňují v mnoha případech dosáhnout asymptoticky téměř lineární 
složitosti. Neznáme však žádné  
expe\-rimentální výsledky, které by porovnávaly použití Fibonacciho 
hald a např. $d$-regulárních hald v těchto grafových 
algoritmech v praxi. Takže neznáme podmínky, za 
kterých jsou Fibonacciho 
haldy lepší než třeba $d$-regulární haldy, 
ani nevíme, do jaké míry je to jen teoretický 
výsledek a do jaké míry jsou opravdu prakticky použitelné. 

trie
---
- prostě prefixový strom, kde nody jsou prefixy a listy jsou slova
- na texty se to hodí - jde rychle dělat reTRIEvaly, delety, insery, sorty, a tak.
- koubek k tomu v prvním díle datovek nemá nic, druhého dílu se bojím, protože jsem si ho neupravoval

B stromy
---
- koubek tu má definovaný (a,b) stromy, B-stromy jsou pak jejich omezení, 23 stromy jsou pak jejich ještě větší omezení
- takže následují ab stromy, pak pudu zase zpátky k B stromům
- dáme a,b, že 2<=a<=(b+1)/2
- potom
    - a,b strom je takový, že každý nod má mezi a-b dětských nodů
    - root má maximálně b synů a minimálně 2
    - cesty z rootu do listu jsou všechny stejně dlouhé
- výška stromu s n listy je O(log n) maximálně
- pokud necháme v listech to, co chceme reprezentovat, a ve vnitřních nodech si budeme pamatovat největší spodní prvek, tak pak najednou nemusíme mít nic v listech, protože všechno je v těch intervalových nodech, kromě nejpravějšího
    - ale to je takový nepřehledný podle K
        - naopak většina literatury používá notaci, co Koubkovi přišla nepřehledná, tak já nevim, používám ji i já dál
- B strom je totéž, jenom vezmeme n a horní zaokrouhlení n/2, a 2,3 je jeho případ, následující na něm platí úplně stejně
- používám nekoubkovskou notaci, viz http://web.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch13.html
- insert
    - vložíme do listu
    - jestli je přeplněný, pošleme prostřední do rodiče 
- když mažem, vezmeme si místo něj buď nejlevějšího nebo nejpravějšího možného
    - mělo by to jít, protože min 2 syni
    - když se tím stane, že tam nic neni
        - když to jde, vezmeme si plného souseda a hodíme ho do parenta , toho si vememe
        - když to nejde - se sousedem ho sloučíme, resp. souseda dáme do otce a pověsíme se za něj
